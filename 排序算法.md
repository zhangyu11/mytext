# 排序算法
***
#### 冒泡排序
冒泡排序是一种简单的排序算法，它重复地遍历要排序的相邻数据，一次比较两个相邻元素，如果它们的顺序错误就将它们交换过来，直到所有的数据全部比较完成为止。
```
    public static void bubbleSort(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - i - 1; j++) {
                if (nums[j] > nums[j + 1]) {
                    int temp = nums[j + 1];
                    nums[j + 1] = nums[j];
                    nums[j] = temp;
                }
            }
        }
    }
```

#### 选择排序
选择排序是一种简单直观的排序算法，它的基本思想是：首先在未排序的数列中找到最小/最大元素，然后将其存放到数列的起始位置/末尾位置，再从剩余未排序的元素中继续寻找最小/最大元素，然后放到已排序序列的末尾，以此类推，直到所有元素均排序完毕。
```
public static void selectSort(int[] nums) {
        int len = nums.length;
        for (int i = len - 1; i >= 0; i--) {  // 从数组末尾开始遍历
            int k = i;
            for (int j = i - 1; j >= 0; j--) {  
                if (nums[j] > nums[k]) {  // 从未排序数列中找到最大值，并记录其索引
                    k = j;
                }
            }
            int temp = nums[k];  // 将找到的未排序数列中的最大值存放到已排序序列的末尾
            nums[k] = nums[i];
            nums[i] = temp;
        }
    }
```

#### 快速排序
快速排序是一种高效的排序算法，基本思想是通过一趟排序将要排序的数据分隔成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
```
public static void quickSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int i = left;
        int j = right;
        int base = nums[left];
        while (i < j) {
            while (nums[j] >= base && i < j) {
                j--;
            }
            int temp = nums[j];
            nums[j] = nums[i];
            nums[i] = temp;

            while (nums[i] <= base && i < j) {
                i++;
            }
            temp = nums[j];
            nums[j] = nums[i];
            nums[i] = temp;
        }
        quickSort(nums, left, i - 1);
        quickSort(nums, i + 1, right);
    }
```

#### 插入排序
插入排序是一种简单直观的排序算法，它的基本思想是将数组分为已排序区间和未排序区间，每次取未排序区间的第一个元素，将其插入到已排序区间中的适当位置，直到未排序区间为空。
```
    public static void insertSort(int[] nums) {
        int n = nums.length;
        for (int i = 1; i < n; i++) {
            for (int j = i; j > 0; j--) {
                if (nums[j] < nums[j - 1]) {
                    int temp = nums[j];
                    nums[j] = nums[j - 1];
                    nums[j - 1] = temp;
                } else {
                    break;
                }
            }
        }
    }
```

#### 希尔排序
希尔排序是插入排序的一种改进算法，也称为缩小增量排序。它通过将原始序列分成若干个子序列分别进行插入排序，然后逐步缩小子序列的长度，直到子序列长度为1，最终完成排序。
```
    public static void hillSort(int[] nums) {
        int len = nums.length;
        for (int gap = len / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < len; i++) {
                for (int j = i; j - gap >= 0; j -= gap) {
                    if (nums[j] < nums[j - gap]) {
                        int temp = nums[j];
                        nums[j] = nums[j - gap];
                        nums[j - gap] = temp;
                    } else {
                        break;
                    }
                }
            }
        }
    }
```

#### 归并排序
归并排序是一种基于分治思想的排序算法，它的基本思路是将待排序的序列分成若干个子序列，每个子序列都是有序的，然后再将这些有序的子序列合并成一个有序的序列。
具体的实现步骤如下：
1. 将待排序序列递归地分成两个子序列，直到每个子序列只有一个元素为止。
2. 将两个有序子序列合并成一个有序序列，合并过程中需要使用一个额外的数组来存储合并后的结果。
3. 重复步骤2，直到所有子序列合并成一个完整的有序序列。

```
public static int[] mergeSort(int[] nums, int left, int right) {
        if (left < right) {
            int mid = (right + left) / 2;
            nums = mergeSort(nums, left, mid);
            nums = mergeSort(nums, mid + 1, right);
            merge(nums, left, mid, right);
        }
        return nums;
    }

    private static void merge(int[] nums, int left, int mid, int right) {
        int[] arrs = new int[right - left + 1];
        int k = 0;
        int i = left;
        int j = mid + 1;
        while (i <= mid && j <= right) {
            if (nums[i] < nums[j]) {
                arrs[k++] = nums[i++];
            } else {
                arrs[k++] = nums[j++];
            }
        }
        while (i <= mid) {
            arrs[k++] = nums[i++];
        }
        while (j <= right) {
            arrs[k++] = nums[j++];
        }
        for (int l = 0; l < k; l++) {
            nums[left++] = arrs[l];
        }
    }
```

#### 堆排序
堆排序是一种基于堆数据结构的排序算法，它的时间复杂度为O(nlogn)。
堆是一种特殊的树形数据结果，它满足以下两个条件：
1. 堆是一个完全二叉树，即除了最后一层，其他层的节点数都是满的，最后一层的节点都靠左排列。
2. 堆中每个节点的值都大于等于（或小于等于）其子节点的值。

堆排序的基本思想是将待排序的序列构建成一个堆，然后依次将堆顶元素（最大或最小值）取出，放到有序区间的末尾，再重新调整堆。重复以上过程，直到整个序列有序。
堆排序的具体实现步骤如下：
1. 构建初始堆：将待排序序列构建成一个大根堆（或小根堆）。
2. 将堆顶元素与末尾元素交换：将堆顶元素（最大或最小值）与末尾元素交换，使末尾元素为有序区间的一部分。
3. 调整堆：将剩余的元素重新构建成一个堆，重复步骤2和步骤3，直到整个序列有序。

```
public static void heapSort(int[] nums) {
        int len = nums.length;
        for (int i = len / 2 - 1; i >= 0; i--) {
            adjustHeap(nums, i, len);
        }
        for (int i = len - 1; i >= 0; i--) {
            swap(nums, i, 0);
            adjustHeap(nums, 0, i);
        }
    }

    private static void adjustHeap(int[] nums, int i, int len) {
        int temp = nums[i];
        for (int k = 2 * i + 1; k < len; k = k * 2 + 1) {
            if (k + 1 < len && nums[k + 1] > nums[k]) {
                k++;
            }
            if (nums[k] > temp) {
                nums[i] = nums[k];
                i = k;
            } else {
                break;
            }
        }
        nums[i] = temp;
    }

    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

#### 基数排序
基数排序（Radix Sort）是一种非比较排序算法，它根据元素的每个位上的数字来进行排序。基数排序的思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。具体实现时，可以使用桶排序的思想，将数字按照个位、十位、百位等位置进行排序。
```
    public static void radixSort(int[] nums){
        int max = nums[0];
        for (int num : nums) {
            if (num > max) {
                max = num;
            }
        }
        int num = 0;
        while (max > 0){
            max = max / 10;
            num++;
        }
        List<LinkedList<Integer>> list = new ArrayList<>(10);
        for (int i = 0; i < 10; i++) {
            list.add(new LinkedList<>());
        }
        for (int i = 1; i <= num; i++) {
            for (int value : nums) {
                int radio = (value / (int) Math.pow(10, i - 1)) % 10;
                list.get(radio).add(value);
            }
            int k = 0;
            for (int j = 0; j < 10; j++) {
                for (int p: list.get(j)) {
                    nums[k++] = p;
                }
                list.get(j).clear();
            }
        }
    }
```


